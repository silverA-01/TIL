# Model

## 데이터베이스(DataBase)의 필요성
`05_form.md`에서 사용자가 입력한 데이터를 특정 함수의 인자 `request`로 전달 받아 변수로서 html에 사용해보았다. 하지만 사용자가 입력한 데이터는 일시적으로 저장될 뿐, 다음 입력값이 제출되면 이전 데이터를 찾을 수 없다. 

**입력받은 데이터를 영구적으로 저장**하기 위해서는 데이터를 **데이터베이스(DB)에 저장**해야 한다.

## Model
장고는 MTV 디자인 패턴을 따른다고 이전에 설명했다. MTV(Model Template View)에서 데이터베이스와 관련된 것이 Model이다.

![Django MTV Design Pattern](./asset/django_MTV.png)

모델은 데이터를 저장하는 데이터베이스(DB)를 관리한다. 모델은 class로 정의되며 하나의 class가 하나의 DB Table이다. 

### ORM(Object Relational Mapping)
장고에서는 파이썬 언어를 사용하고, DB에서는 SQL 언어를 사용하기 때문에 장고와 DB가 통신하는 것은 원칙적으로 불가능하다. 하지만 **ORM**이 파이썬과 SQL의 중간다리 역할을 해준다. 
- ORM은 **객체(Python)와 관계(RDBMS-SQL)를 매핑(대응)해주는 작업**을 한다. 
- ORM으로 장고 Model에서 파이썬 코드로 DB를 조작할 수 있다.
- ORM의 역할을 하는 것은 다양하다. 대표적으로 파이썬에서는 `SQLalchemy` 가 있다. 하지만, 장고에서는 장고에 내장되어 있는 `Django ORM`만 사용해도 충분하다.

## `hospital` App의 Model  
### 1. Local App `hospital` 생성 및 등록
1. `00_INTRO` 프로젝트 폴더에 Local App `hospital` 생성한다. `hospital` App의 `models.py`에서 클래스를 생성하여 DB의 Table과 어떻게 연결되는지 확인할 것이다.
```bash
$ python manage.py startapp hospital
```

2. `intro.settings`에서 `INSTALLED_APPS`에 `hospital` App을 등록한다.
```python
INSTALLED_APPS = [
    'django.contrib.admin',
    'django.contrib.auth',
    'django.contrib.contenttypes',
    'django.contrib.sessions',
    'django.contrib.messages',
    'django.contrib.staticfiles',
    'home',
    'form',
    'hospital',
]
```

### 2. `hospital.models`에서 클래스 `Patient` 정의
`hospital` App 폴더 내의 `models.py`에서 `00_INTRO` 프로젝트의 DB와 연결될 class를 정의할 것이다. `models.py`에 정의하는 class는 해당 프로젝트의 `db.sqlite3`, DB인 SQL의 Table과 연결된다.

class `Patient` 정의한다.
```python
from django.db import models

class Patient(models.Model):
    pass
```
- `Patient`는 클래스명으로 임의로 정한 것이기 때문에 다른 것으로 작성해도 괜찮다. 클래스명은 DB인 SQL에 전달될 때 `APP이름_클래스이름` 형태의 Table이 생성된다.
- `class Patient(models.Model):` :  클래스 `Patient`가 `models`의 클래스 `Model`을 상속받는다는 의미이다.

### 3. `Patient`의 클래스 변수 생성
클래스 변수는 DB의 Table의 Column과 연결된다. 

클래스 변수 `name`, `age`, `height`를 생성해 데이터 타입을 지정해주었다.
```python
from django.db import models

class Patient(models.Model):
    name = models.CharField(max_length=30)
    age = models.IntegerField()
    height = models.FloatField()
```
- `models.CharField(max_length=30)` : `models`의 클래스 `CharField`를 사용하여 문자열 타입의 데이터만 입력받을 수 있도록 데이터 타입 지정
  - 문자열 데이터에 대해서는 입력받을 수 있는 최대 길이 `max_length`를 지정해줘야 한다. 문자열 데이터가 입력받을 수 있는 최대길이를 30으로 지정해주었다.
- `models.IntegerField()` : `models`의 클래스 `IntegerField`를 사용하여 정수 타입의 데이터만 입력받을 수 있도록 데이터 타입을 지정
- `models.FloatField()` : `models`의 클래스 `FloatField`를 사용하여 실수 타입의 데이터만 입력받을 수 있도록 데이터 타입을 지정

### 4. 서버실행 후 DB 확인
1. 처음으로 `model.py`에 클래스를 정의하고 서버를 실행하면 프로젝트 내부에 DB와 관련된 `db.sqlite3` 파일이 생성된 것을 확인할 수 있다.
  - ```bash
    $ python manage.py runserver
    ```

2. VSCode에서 아래 이미지처럼 `SQLite Viewer` extension을 설치하면 SQL이 보기 편해진다. 선택 사항이다.
  - !['SQLite Viewer' extension](./asset/SQLite_Viewer.png)


3. ..`db.sqlite3` 파일에 들어가면 아래 이미지처럼 Table에 아무것도 없다는 것을 확인할 수 있다. 우리가 정의한 클래스 `Patient`를 DB의 Table에 전달해야 한다.
  - !['db.sqlite3' 확인](./asset/db_1.PNG)


### 5. 클래스 DB화
1. 클래스 `Patient`를 DB의 Table에 전달하려면 터미널에서 아래와 같은 코드를 작성해야한다. 프로젝트 파일 경로에서 진행해야 한다.
  - ```bash
    $ python manage.py makemigrations hospital
    ```
  - 터미널에서 위 코드를 실행하면 아래와 같이 응답받는다. `hospital` App 폴더에 하위폴더 `migrations`에 `0001_initial.py`가 생성되었다. 
  - ```bash
    Migrations for 'hospital':
      hospital\migrations\0001_initial.py
        - Create model Patient
    ```

2. 생성된 `hospital/migrations/0001_initial.py` 파일을 확인하면 아래와 같다.
  - ```python
    # Generated by Django 5.0.1 on 2024-01-14 16:09

    from django.db import migrations, models


    class Migration(migrations.Migration):

        initial = True

        dependencies = [
        ]

        operations = [
            migrations.CreateModel(
                name='Patient',
                fields=[
                    ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                    ('name', models.CharField(max_length=30)),
                    ('age', models.IntegerField()),
                    ('height', models.FloatField()),
                ],
            ),
        ]
    ```
   - 우리가 `hospital.models`에서 정의한 클래서 `Patient`에 대한 내용이 담겨있다. 클래스 변수인 `name`, `age`, `height` 외에 `id`가 생성된 것을 확인할 수 있다.
   - `id`는 해당하는 클래스와 연동될 DB에서 데이터가 입력될 때마다 자동으로 생성하는 `primary_key` 칼럼(column)이다. `pk`는 `id`와 같은 클래스 변수로 사용된다.

3. 최종적으로 `0001_initial.py`에 저장된 내용을 DB에 전달하기 위해서 터미널에서 아래 코드를 작성한다. 프로젝트 파일 경로에서 작성해야 한다.
  - ```bash
    $ python manage.py migrate hospital
    ```
  - 터미널에서 코드를 실행하면 아래와 같이 응답받는다. 
  - ```bash
    Operations to perform:
      Apply all migrations: hospital
    Running migrations:
      Applying hospital.0001_initial... OK
    ```
4. `db.sqlite3` 파일을 새로고침하면 `hospital_patient` 테이블이 추가된 것을 확인할 수 있다. 컬럼에 Primary key인 `id`와 클래스 변수로 할당한 `name`, `age`, `height`가 컬럼명으로 들어가 있는 것을 확인할 수 있다.
  - !['hospital/moels.py'에 정의한 클래스 'Patient'와 연결된 SQL Table 'hospital_patient'](./asset/class_Patient_db_1.PNG)
  - `makemigrations`, `migrate` 코드를 통해 `hospital` App의 `models.py`에 정의한 클래스 `Patient`를 DB인 SQL Table로 이주(migrate)시킨 것이다.

## `django_extensions` 설치
터미널에서 아래 코드를 입력해 `django_extensions` 설치해준다. 해당 프로젝트 경로에서 실행한다.
```bash
$ pip install django_extensions
```
- `django_extensions`는 장고에서 공식적으로 만든 App이 아니라 다른 팀에서 장고 라이브러리로 만든 것이다. 
- `django_extensions`를 설치하면 `shell_plus` 기능을 사용할 수 있다.
- 이렇게 3rd Party Apps로 설치한 외부 라이브러리 App은 프로젝트의 마스터(관리) 폴더의 `settings.py`의 `INSTALLED_APPS`에 등록해줘야 한다.

```python
INSTALLED_APPS = [
    # 장고 기본 Apps
    'django.contrib.admin',
    'django.contrib.auth',
    'django.contrib.contenttypes',
    'django.contrib.sessions',
    'django.contrib.messages',
    'django.contrib.staticfiles',

    # 3rd Party Apps
    'django_extensions',

    # Local Apps
    'home',
    'form',
    'hospital',
]
```
- 기본 설치 APPS, 3rd Party APPS, Local APPS을 구분해서 `INSTALLED_APPS` 리스트에 추가하는 것이 좋다.
    - **3rd Party App**은 `pip`로 설치한 APP, 즉 외부 라이브러리 앱을 의미
    - **Local APP**은 장고에서 `python manage.py startapp`으로 직접 생성한 앱을 의미
  - 3rd Party Apps 설치 후 혹은 Local Apps 생성 후에는 반드시 `settings.py`의 `INSTALLED_APPS`의 리스트에 관련 Apps를 등록해야 작동한다.
  - APP을 추가 작성한 마지막에 **Trailing Commas(`,`)** 를 작성해줘야 한다.

### `shell_plus`
터미널에서 `shell_plus`를 사용하면 기존 `shell`보다 편하게 사용할 수 있다. `hospital.models`의 클래스와 연결된 SQL Table에 데이터 CRUD(생성, 조회, 수정, 삭제)를 할 때 `shell_plus`를 사용할 것이다.

터미널에서 프로젝트 파일(`00_INTRO`) 경로에서 아래 코드를 입력후 실행하면 `shell_plus`를 터미널로 사용할 수 있다.
```bash
$ python manage.py shell_plus
```

 `shell_plus`가 아래처럼 터미널에 나타나는 것을 확인할 수 있다.
 ![shell_plus](./asset/shell_plus.PNG)

## DB에서 데이터를 다루는 방법 - `CRUD`
**CRUD**는 DB에서 데이터를 다루는 방법 4가지인, Create(생성), Read(읽기), Update(갱신), Delete(삭제)를 묶어서 일컫는 말이다. CRUD는 DB뿐만 아니라 대부분의 컴퓨터 소프트웨어가 가지는 기본적인 데이터 처리 기능이다.
 - 생성, 수정, 삭제는 DB의 데이터가 바뀐다. 즉, 위험도가 높다.
 - 조회는 DB의 데이터를 탐색하는 것이기 때문에 상대적으로 위험도가 낮다.

|이름|DB의 조작|SQL|설명|
|---|---|---|---|
|Create|생성|INSERT| 새로운 데이터를 추가|
|Read/Retrieve|조회/인출|SELECT| 기존 데이터를 검색|
|Update|수정|UPDATE|기존 데이터를 편집|
|Delete/Destory|삭제/파괴|DELETE|기존 데이터를 삭제|

`shell_plus`을 터미널로 사용해서 DB의 `hospital_table` Table에 데이터를 CRUD(생성, 조회, 수정, 삭제)를 진행해보자.


## 1.Create(생성) - Table에 하나의 row 생성
클래스 인스턴스 생성 후, 클래스 인스턴스에서 클래스 변수에 데이터 값을 각각 할당하여 DB의 테이블에 하나의 row를 생성할 수 있다. 크게 세 가지 방법이 있다.

### 1. Create 생성 방법 (1)
클래스 인스턴스 생성 후, 클래스 인스턴스에서 클래스 변수에 데이터 값을 각각 할당하여 `save()` 메서드로 저장하면 DB에 할당된 값이 해당 칼럼의 row 데이터로 생성된다.
```shell
In [1]: p1 = Patient()

In [2]: p1.name = 'Noah'

In [3]: p1.age = 22

In [4]: p1.height = 179.2

In [5]: p1.save()
``` 
   1. `p1 = Patient()` : 클래스 `Patient`의 인스턴스 `p1`을 생성한다.
      - `p1`이라는 인스턴스명은 임의로 정한 식별자이다. 
   2. `p1.name` : 클래스 `Patient`의 인스턴스로서 클래스 `Patient`의 클래스 변수 `name` 에 접근한다.
      - 클래스 `Patient`의 클래스 변수 `name`은 DB의 테이블 `hospital_table`의 칼럼 `name`과 연결되어 있다.
      - ` p1.name = 'Noah'` : 클래스 변수 `name`에 `'Noah'`라는 문자열 객체를 할당했다.
      - 문자열 객체를 할당한 이유는 `hospital.model`에서 `name`이라는 클래수 변수에 입력받을 수 있는 데이터 타입을 지정해 주었기 때문이다.
        -  `models.CharField(max_length=30)`
   3. 마찬가지로 클래스 변수 `age`, `heigt`에 접근해 `22`, `179.2`라는 정수, 실수 객체를 할당했다.
   4. `p1.save()` : 마지막으로 클래스 인스턴스 `p1`에 대해 `save()` 메서드로 저장해야 DB에 실제로 저장된다.
   5. `db.sqlite3` 파일을 새로고침하면 `hospital_patient` 테이블에서 `p1`에 입력한 각 column에 해당하는 row 데이터가 추가된 것을 확인할 수 있다.
   
![인스턴스 p1이 DB에 저장](./asset/class_Patient_db_2.PNG) 

### 2. Create 생성 방법 (2)
클래스에서 클래스 변수에 대한 값을 할당한 채로 클래스 인스턴스를 생성하고 `save()` 메서드로 저장하면 DB에 할당된 값이 해당 칼럼의 row 데이터로 생성된다.
```shell
In [6]: p2 = Patient(name='Yejun', age=22, height=183)

In [7]: p2.save()
```
  1. 클래스 `Patient`의 클래스 변수 `name`, `age`, `height`에 각각 `Yejun`, `22`, `183` 객체를 할당한 상태에서 클래스 인스턴스 `p2`를 생성했다.
  2. `save()` 메서드로 저장하면 DB에서 `p2`에 할당된 각 column에 해당하는 row 데이터가 추가된 것을 확인할 수 있다.

 ![인스턴스 p2가 DB에 저장](./asset/class_Patient_db_3.PNG)

### 3. Create 생성 방법 (3)
`save()` 메서드를 사용하지 않고 다음과 같이 바로 DB에 데이터를 추가할 수 있다.
```shell
In [9]: p3 = Patient.objects.create(name='Eunho', age=20, height=184)
```

![인스턴스 p3가 DB에 바로 저장](./asset/class_Patient_db_4.PNG)

## 2. Read(조회) - Table의 특정 row 조회
### 1. 전체 조회 - `all()` 메서드
```python
<클래스명>.objects.all()
```
`all()` 메서드는 DB 테이블에서 모든 객체를 전달받은 QuerySet를 반환한다.

**QuerySet(쿼리셋)** 은 DB에서 전달받은 객체들의 모음(list)이다. Python으로 작성한 코드가 SQL로 mapping되어 QuerySet이라는 자료 형태로 값이 넘어온다. 하위 코드들은 DB에 저장된 모든 객체를 불러온다.

QuerySet(쿼리셋)은 DB에서 데이터를 읽고, 필터를 걸거나 정렬할 수 있다.

클래스 `Patient`에 `all()` 메서드를 적용해보겠다.
```shell
In [10]: patient = Patient.objects.all()

In [11]: patient
Out[11]: <QuerySet [<Patient: Patient object (1)>, <Patient: Patient object (2)>, <Patient: Patient object (3)>]>
```
- `Patient.objects.all()` : 클래스 `Patient`에 대한 DB에서 각 row를 객체로 받아, 모든 객체를 묶은 QuerySet을 반환한다. 이를 `patient`라는 변수에 할당했다.

```shell
In [12]: Patient.objects.values()
Out[12]: <QuerySet [{'id': 1, 'name': 'Noah', 'age': 22, 'height': 179.2}, {'id': 2, 'name': 'Yejun', 'age': 22, 'height': 183.0}, {'id': 3, 'name': 'Eunho', 'age': 20, 'height': 184.0}]>

In [13]: Patient.objects.values('name')
Out[13]: <QuerySet [{'name': 'Noah'}, {'name': 'Yejun'}, {'name': 'Eunho'}]>
```
- QuerySet에 담긴 object에 대해 더 자세히 이해하기 위해 `values()` 메서드를 사용해보자.
- `values()` 메서드는 QuerySet을 딕셔너리 형태로 반환한다. 
- `Patient.objects.values()`를 보면 `Patient`에 대한 테이블의 각 row 데이터들이 딕셔너리 형태로 담겨있는 QuerySet을 확인할 수 있다.
- `values()` 메서드에 인자로 column명을 넣으면 해당 column과 관련된 데이터만 딕셔너리형태로 가져올 수 있다.

```shell
In [10]: patient = Patient.objects.all()

...

In [13]: for p in patient:
    ...:     print(p.name)
    ...: 
Noah
Yejun
Eunho


In [14]: patient_name = []

In [15]: for p in patient:
    ...:     patient_name.append(p.name)
    ...: 

In [16]: patient_name
Out[16]: ['Noah', 'Yejun', 'Eunho']

```
-  QuerySet으로 반환되었어도 실제로 DB에 query가 이루어지지는 않는다. 이것은 QuertSet의 lazy한 특성 때문인데, 실제로 데이터를 가져오려면(fetch), 위 코드처럼 for문을 이용해 QuerySet을 iterate시켜야 한다. 
- `patient`는 리스트 형태인 QuerySet이기 때문에 iterable(순회가능한) 객체임을 알 수 있다. 따라서 for문을 활용해서 전체 데이터에서 특정 조건에 대한 데이터들을 받아 볼 수 있다. 
- `patient_name`과 같이 특정 리스트에 원하는 조건의 데이터를 리스트에 추가할 수도 있다.

### 2. 단일 조회 - `get()` 메서드
```python
<클래스명>.objects.get(조건)
```
`get()` 메서드는 조건에 해당하는 1개의 row를 객체로 반환한다.
- 조건에 해당하는 row가 존재하지 않는 경우, `matching query does not exit` 에러 발생한다.
- 1개의 row만 반환하기 때문에, 해당 조건에 해당하는 데이터가 여러개일 경우 `MultipleObjectReturned` 에러 발생한다.
- 이러한 에러에 대해 아래에서 소개할 `filter()` 메서드를 사용하면 된다.

```shell
In [14]: noah_data = Patient.objects.get(name='Noah')

In [15]: noah_data
Out[15]: <Patient: Patient object (1)>

In [16]: print(noah_data.name, noah_data.age, noah_data.height)
Noah 22 179.2
```
1. `Patient.objects.get(name='Noah')` : 클래스 `Patient`와 연결된 DB의 테이블에서 `name='Noah'`에 대한 조건을 만족하는 1개의 row 데이터를 QuerySet 객체로 받는다.
2. 원하는 조건의 데이터가 담긴 객체를 `noah_data` 변수에 할당했다.
3. `noah_data.name` : `noah_data`에서 클래스 변수 `name` 연결된 DB의 데이터 `Noah`를 확인할 수 있다.
4. `noah_data`에서 클래스 변수 `age`, `height`에 대해 접근하면 변수와 연결된 DB의 데이터 `22`, `179.2`를 확인할 수 있다.

```shell
In [17]: noah_data.id
Out[17]: 1

In [18]: noah_data.pk
Out[18]: 1
```
![noah_data의 id=pk=1인 것을 확인](./asset/class_Patient_db_4.PNG)
- noah_data에 해당하는 row에서 `id` column에 해당하는 필드가 `1`인 것을 확인할 수 있다.
- `id` column은 장고에서 자동으로 생성하는 primary key로 각 row 데이터 별로 중복되지 않는다. 따라서 특정 `id` 즉, 특정 `pk`를 활용하는 것이 가장 확실하게 데이터에 조회할 수 있는 방법이다.
  - `pk`는 primary key의 약자이다.
  - `id`로 조회한 데이터와 `pk`로 조회한 데이터는 일치하다. 같은 값을 나타내기 때문이다. 보통 `id`보다 `pk`를 활용해 객체에 조회한다.

### 3. 조건 조회 - `filter()` 메서드
```python
<클래스명>.objects.fiter()
```
`filter()` 메서드는 조건에 해당하는 여러 row를 모두 묶어 QuerySet 형태의 객체로 반환한다.
- `filter()` 메서드의 인자에 조건을 작성해주면 된다.
- 조건에 해당하는 row가 존재하지 않는 경우, 빈 QuerySet을 반환한다.

```shell
In [19]: age_22 = Patient.objects.filter(age=22)

In [20]: age_22
Out[20]: <QuerySet [<Patient: Patient object (1)>, <Patient: Patient object (2)>]>

In [21]: for n in age_22:
    ...:    print(n.name)
    ...:
    ...:
Noah
Yejun
```
- `Patient.objects.filter(age=22)` : 클래스 `Patinet`에 대한 DB `hospital_patient` 테이블에서 칼럼 `age`가 `22`인 조건을 만족하는 row들을 묶은 QuerySet 객체 반환한다. 이를 `age_22`라는 변수에 할당했다
- `age_22`는 list이기 때문에 for문으로 `name`에 대해 접근할 수 있다.
- for문을 최종적으로 조건(age=22)을 만족하는 `name`에 해당하는 필드를 조회할 수 있다.

## 3. Update(수정) - Table의 특정 필드 수정
`pk(id)`가 `1`인 row의 `age` 칼럼을 `40`으로 수정하고 싶다면 아래와 같이 코드를 작성한다.
```shell
In [22]: p1 = Patient.objects.get(pk=1)

In [23]: p1.age = 40

In [24]: p1.save()
```
1. `get()` 메서드를 사용해 수정하고 싶은 특정 row의 객체를 반환 
2. 수정하고 싶은 column에 대해 값을 재할당한다.
3. `save()` 메서드를 사용해 저장해야 수정된 데이터가 DB에 반영된다.
4. DB에서 확인해보면 해당 조건의 필드가 40으로 수정된 것을 확인할 수 있다.

![특정 필드 update](./asset/class_Patient_db_5.PNG) 

## 4. Delete(삭제) - Table의 특정 row 삭제
```shell

```
1. `get()` 메서드를 사용해 수정하고 싶은 특정 row의 객체를 반환
2. `delete()` 메서드를 활용해 삭제를 실행
  - 저장할 필요없이 바로 삭제가 실행되고, 이는 되돌릴 수 없다.
3. DB에서 확인해보면 해당 조건의 row가 삭제된 것을 확인할 수 있다.

![특정 row 삭제](./asset/class_Patient_db_6.PNG) 

삭제 후 새로운 row를 생성하면, `id` 칼럼은 삭제된 row의 필드 다음 번호가 생긴다. `id`는 primary key로 생성된 row마다 고유한 번호를 부여받기 때문이다.
   - `db.sqlite3` 파일에서 `sqlite_sequence` 테이블에서 새로 생성될 row에 부여할 id 데이터를 저장해놓고 있다.